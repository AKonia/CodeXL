//==================================================================================
// Copyright (c) 2013-2016 , Advanced Micro Devices, Inc.  All rights reserved.
//
/// \author AMD Developer Tools Team
/// \file CpuProfileDataTranslation.h
/// \brief CPU profile data translation interface.
/// \note This API is only valid for \ref sampling profile data generated by
///       the \ref CpuProfileControl.h.  Older profile data may ignore the specified intervals.
///
//==================================================================================
// $Id: //devtools/main/CodeXL/Components/CpuProfiling/Backend/AMDTCpuProfilingTranslation/inc/CpuProfileDataTranslation.h#7 $
// Last checkin:   $DateTime: 2016/04/14 01:44:54 $
// Last edited by: $Author:  AMD Developer Tools Team
// Change list:    $Change: 569055 $
//=====================================================================

/** There are two forms of profile data, the raw data in files with a ".prd"
    extension and aggregated data like CodeAnalyst uses.

    To use these functions, you must start with either \ref fnOpenProfile or
    \ref fnOpenAggregatedProfile.  When you are finished, you must call
    \ref fnCloseProfile to free the file handles.

    When using the same ReaderHandle, the code is thread safe.

    There are five groups of functions: \ref datafiles, \ref timemarks, \ref
    datasets, \ref rules, and \ref data.  Rules will filter the data returned
    by the queries.

    \defgroup datafiles Data Files
    These functions handle reading profile data files.

    Raw profile data files have a ".prd" extension and should be opened with
    \ref fnOpenProfile.  Aggregate profile data files created by CodeAnalyst
    have a ".tbp" or ".ebp" extension and should be opened with \ref
    fnOpenAggregatedProfile.

    A profile data file must be opened to generate a reader handle, which will
    be used in all other interactions.  When the reader handle is no longer
    useful, it should be disposed of with \ref fnCloseProfile.

    \defgroup timemarks Time Marks
    A way to specify intervals in raw profile data files.

    Time marks allow you to specify intervals of interest to a data set.  Time
    marks are synchronized to a particular node, so any useful marks should be
    generated on the same node during the profile, possibly with the API
    function \ref fnGetCurrentTimeMark.

    Time marks are only useful to non-aggregated profile data files opened with
    \ref fnOpenProfile.

    \defgroup datasets Data Sets
    A collection of samples within specified intervals.

    A single profile may have multiple data sets, each made of multiple
    intervals of interest.  An aggregated profile data file only has one
    data set available

    A data set may have multiple contiguous or non-contiguous intervals.  If
    the intervals overlap, the data will only be counted once.  If \ref
    fnOpenProfile was used to open a .prd file, the default data set has the
    same name as the .prd file and contains the entire [start, end] interval.

    No data will be available before \ref fnAggregateDataSets aggregates the
    data to the sets, if \ref fnOpenProfile was used.

    The default data set name is NULL.  This covers the entire profile interval.

    The expected use would be to open the profile data file with \ref
    fnOpenProfile, create desired data sets with \ref fnAddDataSet, then call
    \ref fnAggregateDataSets to aggregate the data from the data file into the
    sets.

    \defgroup rules Data Rules
    A way to show only part of the data set.

    This will let you filter the displayed data.  Setting the same rule twice
    will overwrite the previous setting.  The filters apply to all \ref data.

    The rules affect both the aggregation of data and the data returned.  The
    best way to do this would be to reset the rules for the aggregation and
    only set the rules for the data queries

    The expected use would be to open the profile data file with \ref
    fnOpenProfile, create desired data sets with \ref fnAddDataSet, then call
    \ref fnAggregateDataSets to aggregate the data from the data file into the
    sets, set any of the rules, and then retrieve the data.
    Alternately, you could open an aggregated data file with \ref
    fnOpenAggregatedProfile, then set the rules, and finally retrieve the data.

    \defgroup data Data Queries
    Retrieves the information contained within a data set.

    The functions which return data need the data to be appropriate.  If \ref
    fnOpenProfile was used, \ref fnAggregateDataSets needs to be called before
    these functions will return valid data.  If you do not specify the data set
    name, the default data set will be used.

    The expected use would be to open the profile data file with \ref
    fnOpenProfile, create desired data sets with \ref fnAddDataSet, then call
    \ref fnAggregateDataSets to aggregate the data from the data file into the
    sets, set any rules, and then retrieve the data with the queries.
    Alternately, you could open an aggregated data file with \ref
    fnOpenAggregatedProfile, set any rules, and finally retrieve the data.
*/

#ifndef _CPUPROFILEDATATRANSLATION_H_
#define _CPUPROFILEDATATRANSLATION_H_

#include <AMDTOSWrappers/Include/osFilePath.h>
#include "CpuProfilingTranslationDLLBuild.h"
#include "CPA_TIME.h"


class apProfileProgressEvent;

typedef void (*PfnProgressBarCallback)(apProfileProgressEvent& progressEvent);


/****************************************************************************/

/** \typedef ReaderHandle
    \brief A handle to identify which profiles were opened.
    \ingroup datafiles

    The handle is necessary for all functions related to retrieving data from
    the opened profiles.  The two functions that will generate a new valid
    ReaderHandle are \ref fnOpenProfile and \ref fnOpenAggregatedProfile.
*/
typedef void ReaderHandle;

/** This function will open a raw profile data file.

    This function supports the following profile input:
    1. CodeAnalyst profile data with ".prd" file extension
    3. CodeAnalyst profile data with ".tbp" or ".ebp" file extension
    2. CodeAnalyst profile data with ".caperf" file extension (Linux only)
    5. OProfile samples directory (/var/lib/oprofile/samples) (Linux only)
    4. Linux Perf output file "perf.data" (Linux only)
    6. OProfile XML data file from opreport (Linux only)

    \ingroup datafiles
    @param[in] pPath The profile data file or directory of interest
    @param[out] pReaderHandle The handle to use for retrieving the data
    \return The success of opening the profile
    \retval S_OK Success
    \retval E_INVALIDARG either pPath or pReaderHandle is not a valid
    pointer
    \retval ERROR_FILE_NOT_FOUND The file wasn't found
    \retval E_ACCESSDENIED The file wasn't able to be opened
    \retval E_HANDLE The reader handle is already open
    \retval E_OUTOFMEMORY no more memory is available
    \retval E_UNEXPECTED an unexpected error occurred
*/
CP_TRANS_API HRESULT fnOpenProfile(
    /*in*/ const wchar_t* pPath,
    /*out*/ ReaderHandle** pReaderHandle);

/** Releases all resources appropriately.  Note that after this call, the
    reader handle will not be valid.
    \ingroup datafiles
    @param[in,out] pReaderHandle The handle to close
    \return The success of closing the profile
    \retval S_OK Success
    \retval E_INVALIDARG pReaderHandle was not an open handle
    \retval E_ACCESSDENIED There is data currently being aggregated, and that
    function must be canceled first.
    \retval E_UNEXPECTED an unexpected error occurred
*/
CP_TRANS_API HRESULT fnCloseProfile(
    /*in*/ ReaderHandle** pReaderHandle);

/** \struct ProfileDataSetInterval
    \brief A data set interval is defined by two time marks, [start, end).
    \ingroup datasets

    A data set is defined by one or more data set intervals.  Any intervals
    that end before the start of the profile data or start after the end of the
    profile data will be ignored.

    You can generate the time marks either through the \ref
    fnGetCurrentTimeMark or with the Windows time functions like
    CoDosDateTimeToFileTime().
*/
struct ProfileDataSetInterval
{
    /** interval start */
    CPA_TIME start;
    /** interval end */
    CPA_TIME end;
};

/** This will write the named data set to a file, including all necessary
    call-stack and JIT data files in the same directory.  No filters will be
    applied to the written data.

    \ingroup datasets
    @param[in] pReaderHandle The open reader handle
    @param[in] pDataSetName The data set name to write
    @param[in] pFileName The file name to write to
    @param[out] pPercentComplete an optional way to track the progress of the writing
    \return The success of removing the data set
    \retval S_OK Success
    \retval E_PENDING The profile data was not yet aggregated
    \retval E_INVALIDARG pReaderHandle was not an open handle, or an invalid
    data set name was provided
    \retval E_ACCESSDENIED the access to the path was denied
    \retval E_UNEXPECTED an unexpected error occurred
*/
CP_TRANS_API HRESULT fnCpuProfileDataTranslate(
    /*in*/ ReaderHandle* pReaderHandle,
    /*in*/ const wchar_t* pFileName,
    /*in*/ PfnProgressBarCallback pfnProgressBarCallback,
    /*in*/ const wchar_t* pSearchPath = NULL,
    /*in*/ const wchar_t* pServerList = NULL,
    /*in*/ const wchar_t* pCachePath = NULL);

/** \struct SampleDatumKey
    \brief This structure is a key for the sample count data in \ref SampleData

    \ingroup data
*/
struct SampleDatumKey
{
    /** Which core is the value for */
    int core;
    /** Which performance event is the value for */
    gtUInt64 event;
};

/** This function has to imply that !(a < b) is (a >= b), for the sorting to
    work
*/
inline bool operator< (const SampleDatumKey& temp1, const SampleDatumKey& temp2)
{
    if (temp1.core < temp2.core)
    {
        return true;
    }
    else if (temp1.core > temp2.core)
    {
        return false;
    }
    else if (temp1.event < temp2.event)
    {
        return true;
    }
    else
    {
        return false;
    }
};


/** \struct SampleData
    \brief This structure holds the data
    \ingroup data
*/
struct SampleData
{
    /** How many data are available in the arrays */
    unsigned int count;
    /** The array of keys of the data */
    SampleDatumKey* keyArray;
    /** The array of data */
    gtUInt64* dataArray;
    /** Constructor */
    SampleData() { keyArray = NULL; dataArray = NULL; count = 0;}
};


/** This enum represents the type of module.
    \ingroup data
*/typedef enum
{
    InvalidModType, /**< An invalid module */
    UnmanagedModType, /**< A regular, unmanaged application or library */
    JavaModType, /**< JIT-generated module information */
    ManagedModType, /**< A managed application or library */
    KernelModType, /**< Kernel module> */
    UnknownModType /**< An unknown module */
} ModuleType;

/** \struct ModuleDataType
    \brief This structure holds all the data for module-level samples.
    \ingroup data
*/
struct ModuleDataType
{
    /** The path of the module */
    wchar_t* path;
    /** The process id of the samples, may vary based on rules */
    unsigned int processId;
    /** Whether the module is 64-bit */
    bool is64Bit;
    /** The sample data that occurred in the module */
    SampleData data;
    ModuleDataType() { path = NULL; }
};

/** \struct InstructionDataType
    \brief This structure holds all the data for instruction-level samples.
    \ingroup data
*/
struct InstructionDataType
{
    /** The address of the sampled instruction.
    \note that IBS fetch samples addresses may fall between actual instructions
    */
    gtUInt64 address;
    /** The process id of the samples, may vary based on rules */
    unsigned int processId;
    /** The thread id of the samples, may vary based on rules */
    unsigned int threadId;
    /** The load address of the jit function only provided for JIT samples */
    gtUInt64 jitAddress;
    /** The JIT generated function name, only provided for JIT samples */
    wchar_t* pJitFunctionName;
    /** The JIT generated data file name, only provided for JIT samples */
    wchar_t* pJitDataFile;
    /** The sample data that occurred in the module */
    SampleData data;
    InstructionDataType()
    {
        pJitFunctionName = NULL;
        pJitDataFile = NULL;
    }
} ;

/** The less than function for the \ref InstructionDataType
*/
inline bool operator< (const InstructionDataType& temp1,
                       const InstructionDataType& temp2)
{
    if (temp1.address < temp2.address)
    {
        return true;
    }
    else if (temp1.processId > temp2.processId)
    {
        return false;
    }
    else if (temp1.threadId < temp2.threadId)
    {
        return true;
    }
    else
    {
        return false;
    }
};

/** The equality function for the \ref InstructionDataType
*/
inline bool operator== (const InstructionDataType& temp1,
                        const InstructionDataType& temp2)
{
    if (temp1.address != temp2.address)
    {
        return false;
    }
    else if (temp1.processId != temp2.processId)
    {
        return false;
    }
    else if (temp1.threadId != temp2.threadId)
    {
        return false;
    }
    else
    {
        return true;
    }
};

/** \struct JITDataType
    \brief This structure retrieves JIT information for the given address.
    \ingroup data
*/
typedef struct
{
    /** The native code bytes for the instruction at the address */
    const gtUByte* pNativeCodeBytes;
    /** The Java virtual machine reported source file name */
    wchar_t* sourceFileName;
    /** The Java virtual machine reported line number */
    int lineNumber;
} JITDataType ;

/** \struct RawDataType
    \brief This structure holds all the data for one profile sample.

    If the module of a sample is unknown, the full sample address will be
    given.  If the module is known, the offset into the module will be given.

    \note An IBS sample will have multiple data for one sample.

    \ingroup data
*/
typedef struct
{
    /** Sample time mark */
    CPA_TIME timeMark;
    /** The path of the module */
    wchar_t* path;
    /** The load address of the module */
    gtUInt64 loadAddress;
    /** The size of the module */
    gtUInt64 moduleSize;
    /** Sample address */
    gtUInt64 address;
    /** What type of module is it */
    ModuleType type;
    /** The process id of the sample */
    unsigned int processId;
    /** The thread id of the sample */
    unsigned int threadId;
    /** The JIT generated function name, only provided for JIT samples */
    wchar_t* pJitFunctionName;
    /** The JIT generated data file name, only provided for JIT samples */
    wchar_t* pJitDataFile;
    /** Valid if the IBS ops sample data contained a branch target address */
    gtUInt64 ibsOpBranchAddress;
    /** Valid if the IBS ops sample data contained a data cache linear address */
    gtUInt64 ibsOpDcLinearAddress;
    /** Valid if the IBS ops sample data contained a data cache physical address */
    gtUInt64 ibsOpDcPhysicalAddress;
    /** The sample data that occurred in the module */
    SampleData data;
} RawDataType ;

CP_TRANS_API HRESULT fnMigrateEBPToDB(
    /*in*/ const osFilePath& ebpFilePath);

#endif  // _CPUPROFILEDATATRANSLATION_H_